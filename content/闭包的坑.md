下面是一个简单复现：

	package main
	
	import (
		"fmt"
		"net/http"
	)
	
	type Logger struct{}
	
	func (this *Logger) Debug() {
		if this == nil {
			panic("fuck")
		}
		fmt.Println("hello world")
	}
	
	var __logger *Logger
	
	func AppLog() *Logger {
		return __logger
	}
	
	func InitConf() {
		__logger = &Logger{}
	}
	
	// ------内上内容应该是写在log包中，这里是方便演示------
	
	var logger = AppLog()
	
	func HelloWorld(w http.ResponseWriter, r *http.Request) {
		AppLog().Debug() // ok
		logger.Debug()   // panic
	}
	
	func main() {
		InitConf()
		http.HandleFunc("/", HelloWorld)
		http.ListenAndServe(":8088", nil)
	}

会崩。为什么？明明有调InitConf初始化过全局变量`__logger`呀！

都是闭包惹的祸。http.HandlerFunc其实是闭包。

最终HelloWorld中使用的logger不是全局变量的logger，而是闭包里的自由变量。

在闭包生成的时候InitConf()还没被调用，所以`__logger`是nil的，于是闭包里面的自由变量logger是nil的。